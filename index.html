<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GeoMeasure: Dark Mode & Accuracy</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; height: 100vh; overflow: hidden; display: flex; flex-direction: column; background: #eee; }
        
        #map { flex: 1; width: 100%; z-index: 1; }

        /* --- TOP BANNER --- */
        .top-banner {
            position: absolute;
            top: 0; left: 0; right: 0;
            z-index: 1000;
            background: rgba(30, 30, 30, 0.95);
            color: white;
            padding: 10px 15px;
            padding-top: max(10px, env(safe-area-inset-top));
            box-shadow: 0 4px 20px rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .banner-main-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .display-group {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .hud-label { font-size: 11px; text-transform: uppercase; letter-spacing: 1px; color: #aaa; }
        
        .distance-readout { display: flex; align-items: baseline; gap: 4px; }
        .hud-value { font-size: 32px; font-weight: 700; font-variant-numeric: tabular-nums; line-height: 1; }
        .hud-unit { font-size: 14px; color: #888; }
        
        /* Stats Block (Alt + Accuracy) */
        .stats-block {
            display: flex;
            flex-direction: column;
            margin-top: 4px;
        }
        
        .alt-readout { 
            font-size: 13px; 
            color: #4CAF50; 
            font-weight: 500;
        }
        
        .acc-readout {
            font-size: 11px;
            color: #888;
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 2px;
        }

        /* GPS Dot */
        .gps-status {
            width: 8px; height: 8px; border-radius: 50%;
            background: #ccc; display: inline-block;
            box-shadow: 0 0 5px rgba(0,0,0,0.5);
        }
        .gps-status.active { background: #4CAF50; box-shadow: 0 0 8px #4CAF50; }
        .gps-status.error { background: #f44336; }
        .gps-status.searching { background: #FFC107; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0.5; } }

        /* Action Buttons */
        .action-group { display: flex; gap: 8px; }

        .btn-main {
            height: 48px; padding: 0 20px; border-radius: 24px; border: none;
            font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.2s;
            display: flex; align-items: center; justify-content: center; gap: 6px;
            white-space: nowrap; box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        
        .btn-start { background-color: #4CAF50; color: white; flex: 2; }
        .btn-start:active { background-color: #3d8b40; transform: scale(0.96); }
        
        .btn-stop { background-color: #f44336; color: white; animation: pulse 2s infinite; flex: 2; }
        .btn-stop:active { background-color: #d32f2f; transform: scale(0.96); }

        .btn-reuse { 
            background-color: #2196F3; color: white; 
            display: none; flex: 1; padding: 0 15px;
        }
        .btn-reuse:active { background-color: #1976D2; transform: scale(0.96); }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); } 100% { box-shadow: 0 0 0 0 rgba(244, 67, 54, 0); } }

        /* Toolbar */
        .banner-tools {
            display: flex; gap: 10px; padding-top: 5px;
            border-top: 1px solid rgba(255,255,255,0.1);
        }

        .tool-btn {
            background: rgba(255,255,255,0.1); border: none; color: #ddd;
            padding: 8px 12px; border-radius: 6px; font-size: 13px;
            cursor: pointer; display: flex; align-items: center; gap: 6px;
            flex: 1; justify-content: center;
        }
        .tool-btn:hover { background: rgba(255,255,255,0.2); }
        .tool-btn:disabled { opacity: 0.3; cursor: not-allowed; }

        /* --- BASEMAP TOGGLE --- */
        .basemap-toggle {
            position: absolute;
            top: 155px; /* Pushed down slightly */
            right: 15px;
            z-index: 950;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            padding: 0;
            cursor: pointer;
            width: 44px; height: 44px;
            display: flex; align-items: center; justify-content: center;
            border: 2px solid white;
            font-size: 22px;
            user-select: none;
        }
        .basemap-toggle:active { transform: scale(0.95); }

        /* --- BOTTOM LIST --- */
        .bottom-panel {
            position: absolute; bottom: 20px; left: 10px; right: 10px;
            z-index: 900; pointer-events: none;
            display: flex; flex-direction: column; justify-content: flex-end;
            max-height: 40vh;
        }

        .measurements-list {
            background: white; border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            overflow-y: auto; pointer-events: auto;
            max-height: 0; transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .measurements-list.open { max-height: 250px; padding: 5px 0; }
        
        .measurement-item {
            padding: 12px 15px; border-bottom: 1px solid #eee;
            display: flex; justify-content: space-between; align-items: center;
        }
        .measurement-item:last-child { border-bottom: none; }
        
        .m-info { display: flex; flex-direction: column; }
        .m-main { font-weight: 600; font-size: 15px; color: #333; }
        .m-sub { font-size: 12px; color: #666; margin-top: 2px; }
        
        .btn-graph {
            background: #f0f4ff; color: #2196F3; border: none;
            padding: 6px 12px; border-radius: 20px; cursor: pointer;
            font-size: 12px; font-weight: 600;
        }

        /* --- MODAL --- */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.6); z-index: 2000; align-items: center; justify-content: center; padding: 20px; }
        .modal-overlay.active { display: flex; }
        .modal-content { background: white; width: 100%; max-width: 500px; border-radius: 16px; padding: 20px; box-shadow: 0 10px 25px rgba(0,0,0,0.3); }
        .chart-container { width: 100%; height: 200px; background: #f8f9fa; border-radius: 8px; margin: 15px 0; border: 1px solid #eee; }
        .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .modal-title { font-weight: bold; font-size: 18px; color: #333; }
        .close-btn { background: none; border: none; font-size: 24px; cursor: pointer; color: #666; }

        /* Markers */
        .marker-pin { width: 30px; height: 30px; border-radius: 50% 50% 50% 0; background: #2196F3; position: absolute; transform: rotate(-45deg); left: 50%; top: 50%; margin: -15px 0 0 -15px; box-shadow: 1px 1px 4px rgba(0,0,0,0.5); }
        .marker-pin::after { content: ''; width: 14px; height: 14px; margin: 8px 0 0 8px; background: white; position: absolute; border-radius: 50%; }
        .start-marker .marker-pin { background: #4CAF50; }
        .end-marker .marker-pin { background: #f44336; }

    </style>
</head>
<body>

    <!-- TOP BANNER -->
    <div class="top-banner">
        <div class="banner-main-row">
            <div class="display-group">
                <div class="hud-label">Distance to Start</div>
                <div class="distance-readout">
                    <span id="distanceValue" class="hud-value">0.00</span>
                    <span class="hud-unit">meters</span>
                </div>
                
                <div class="stats-block">
                    <div class="alt-readout">
                        <span id="altValue">Alt: ---</span>
                    </div>
                    <div class="acc-readout">
                        <div id="gpsStatus" class="gps-status" title="GPS"></div>
                        <span id="accValue">Searching...</span>
                    </div>
                </div>
            </div>
            
            <div class="action-group">
                <button id="btnReuse" class="btn-main btn-reuse" title="Measure another line from the previous start point">
                    <span>‚Ü©</span> From Last
                </button>
                <button id="btnAction" class="btn-main btn-start">
                    <span>üìç</span> Start
                </button>
            </div>
        </div>

        <div class="banner-tools">
            <button id="btnUndo" class="tool-btn" disabled>
                <span>‚Ü©</span> Undo Last
            </button>
            <button id="btnDownload" class="tool-btn" disabled>
                <span>‚¨á</span> Save GeoJSON
            </button>
        </div>
    </div>

    <!-- BASEMAP TOGGLE -->
    <button id="basemapToggle" class="basemap-toggle" title="Switch Map Style (Streets / Satellite / Dark)">
        üåç
    </button>

    <div id="map"></div>

    <!-- BOTTOM LIST -->
    <div class="bottom-panel">
        <div id="measurementsList" class="measurements-list"></div>
    </div>

    <!-- GRAPH MODAL -->
    <div class="modal-overlay" id="graphModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title">Elevation Profile</div>
                <button class="close-btn" onclick="closeModal()">√ó</button>
            </div>
            <div class="chart-container">
                <canvas id="profileChart"></canvas>
            </div>
            <div style="display: flex; justify-content: space-between; font-size: 13px; color: #666;">
                <span id="modalStartAlt">Start: 0m</span>
                <span id="modalGain">Gain: +0m</span>
                <span id="modalEndAlt">End: 0m</span>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
    <script>
        const state = {
            isMeasuring: false,
            currentLocation: null,
            startPoint: null,
            lastStartPoint: null,
            activeTrace: [],
            segments: [], 
            watchId: null,
            mapMode: 0 // 0: Streets, 1: Satellite, 2: Dark
        };

        const map = L.map('map', { zoomControl: false }).setView([0, 0], 2);
        
        // Define Basemaps
        const basemaps = {
            streets: L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap', maxZoom: 20
            }),
            satellite: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: '&copy; Esri', maxZoom: 19
            }),
            dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; CARTO', maxZoom: 20
            })
        };
        
        // Init default
        basemaps.streets.addTo(map);

        const layers = {
            user: L.layerGroup().addTo(map),       
            active: L.layerGroup().addTo(map),     
            completed: L.featureGroup().addTo(map) 
        };

        const ui = {
            btnAction: document.getElementById('btnAction'),
            btnReuse: document.getElementById('btnReuse'),
            btnUndo: document.getElementById('btnUndo'),
            btnDownload: document.getElementById('btnDownload'),
            basemapToggle: document.getElementById('basemapToggle'),
            distanceValue: document.getElementById('distanceValue'),
            altValue: document.getElementById('altValue'),
            accValue: document.getElementById('accValue'),
            list: document.getElementById('measurementsList'),
            gpsStatus: document.getElementById('gpsStatus'),
            hudUnit: document.querySelector('.hud-unit')
        };

        const createIcon = (type) => L.divIcon({
            className: `${type}-marker`,
            html: `<div class="marker-pin"></div>`,
            iconSize: [30, 42], iconAnchor: [15, 42]
        });

        function init() {
            if (!window.isSecureContext && window.location.hostname !== 'localhost') {
                alert("HTTPS Required for GPS Altitude");
            }
            startGPS();
            
            ui.btnAction.addEventListener('click', toggleMeasurement);
            ui.btnReuse.addEventListener('click', startFromLast);
            ui.btnUndo.addEventListener('click', undoLastSegment);
            ui.btnDownload.addEventListener('click', downloadGeoJSON);
            
            // 3-Way Toggle Logic
            ui.basemapToggle.addEventListener('click', cycleMap);

            window.addEventListener('resize', () => {
                if(document.getElementById('graphModal').classList.contains('active')) {
                   // Resize logic handled in drawChart
                }
            });
        }

        function cycleMap() {
            // Remove all
            map.removeLayer(basemaps.streets);
            map.removeLayer(basemaps.satellite);
            map.removeLayer(basemaps.dark);
            
            state.mapMode = (state.mapMode + 1) % 3;
            
            if (state.mapMode === 0) {
                basemaps.streets.addTo(map);
                ui.basemapToggle.innerText = 'üåç';
            } else if (state.mapMode === 1) {
                basemaps.satellite.addTo(map);
                ui.basemapToggle.innerText = 'üõ∞Ô∏è';
            } else {
                basemaps.dark.addTo(map);
                ui.basemapToggle.innerText = 'üåë';
            }
        }

        function startGPS() {
            if (!navigator.geolocation) {
                ui.hudUnit.innerText = "No GPS";
                return;
            }
            ui.gpsStatus.className = 'gps-status searching';
            
            const options = { enableHighAccuracy: true, timeout: 30000, maximumAge: 0 };
            if (state.watchId) navigator.geolocation.clearWatch(state.watchId);
            state.watchId = navigator.geolocation.watchPosition(updateLocation, handleError, options);
        }

        function updateLocation(position) {
            const { latitude, longitude, altitude, accuracy } = position.coords;
            const latLng = L.latLng(latitude, longitude);
            const currentAlt = altitude !== null ? altitude : 0;
            state.currentLocation = { ...latLng, alt: currentAlt, lat: latitude, lng: longitude };

            layers.user.clearLayers();
            L.marker(latLng, {
                icon: L.divIcon({
                    className: 'user',
                    html: '<div style="background:#2196F3;width:16px;height:16px;border:3px solid white;border-radius:50%;box-shadow:0 0 5px rgba(0,0,0,0.3)"></div>',
                    iconSize:[16,16], iconAnchor:[8,8]
                })
            }).addTo(layers.user);
            L.circle(latLng, {radius: accuracy, color: '#2196F3', weight: 1, fillOpacity: 0.1}).addTo(layers.user);

            ui.gpsStatus.className = 'gps-status active';
            ui.gpsStatus.title = `Accuracy: ${Math.round(accuracy)}m`;
            
            // Stats Updates
            ui.altValue.innerText = `Alt: ${currentAlt.toFixed(1)}m`;
            ui.accValue.innerText = `¬±${Math.round(accuracy)}m`;

            if (state.segments.length === 0 && !state.isMeasuring && map.getZoom() < 5) {
                map.setView(latLng, 18);
            }

            if (state.isMeasuring && state.startPoint) {
                const dist = state.startPoint.distanceTo(latLng);
                ui.distanceValue.innerText = dist.toFixed(2);
                
                state.activeTrace.push({
                    lat: latitude, lng: longitude, alt: currentAlt, dist: dist
                });

                layers.active.eachLayer(l => { if (l instanceof L.Polyline) layers.active.removeLayer(l); });
                L.polyline([state.startPoint, latLng], {
                    color: '#333', dashArray: '10, 10', weight: 3, opacity: 0.8
                }).addTo(layers.active);
            }
        }

        function handleError(err) {
            console.error(err);
            ui.gpsStatus.className = 'gps-status error';
            ui.accValue.innerText = "GPS Error";
        }

        function toggleMeasurement() {
            if (!state.currentLocation) { alert("Waiting for GPS..."); return; }

            if (!state.isMeasuring) {
                startMeasuring(state.currentLocation);
            } else {
                finishSegment();
            }
        }
        
        function startFromLast() {
            if (!state.lastStartPoint) return;
            startMeasuring(state.lastStartPoint, true);
        }

        function startMeasuring(locationObj, isReuse = false) {
            state.isMeasuring = true;
            
            if (isReuse) {
                state.startPoint = locationObj; 
                state.activeTrace = [];
            } else {
                state.startPoint = L.latLng(locationObj.lat, locationObj.lng);
                state.activeTrace = [{
                    lat: locationObj.lat,
                    lng: locationObj.lng,
                    alt: locationObj.alt || 0,
                    dist: 0
                }];
            }

            ui.btnAction.innerHTML = "<span>üõë</span> Stop";
            ui.btnAction.classList.remove('btn-start');
            ui.btnAction.classList.add('btn-stop');
            ui.btnReuse.style.display = 'none';
            ui.btnUndo.disabled = true;
            ui.btnDownload.disabled = true;
            
            layers.active.clearLayers();
            L.marker(state.startPoint, {icon: createIcon('start')}).addTo(layers.active);
        }

        function finishSegment() {
            const endPoint = L.latLng(state.currentLocation.lat, state.currentLocation.lng);
            const straightDist = state.startPoint.distanceTo(endPoint);
            const smoothedTrace = smoothAltitude(state.activeTrace);

            state.lastStartPoint = state.startPoint;

            const segment = {
                id: Date.now(),
                start: state.startPoint,
                end: endPoint,
                distance: straightDist,
                trace: smoothedTrace
            };
            
            state.segments.push(segment);

            const line = L.polyline([segment.start, segment.end], {color: '#2196F3', weight: 5}).addTo(layers.completed);
            L.marker(segment.start, {icon: createIcon('start')}).addTo(layers.completed);
            L.marker(segment.end, {icon: createIcon('end')}).addTo(layers.completed);
            line.bindPopup(`Dist: ${straightDist.toFixed(2)}m`);

            state.isMeasuring = false;
            state.startPoint = null;
            layers.active.clearLayers();
            
            ui.btnAction.innerHTML = "<span>üìç</span> Start";
            ui.btnAction.classList.remove('btn-stop');
            ui.btnAction.classList.add('btn-start');
            ui.btnReuse.style.display = 'flex';
            ui.distanceValue.innerText = "0.00";
            ui.btnUndo.disabled = false;
            ui.btnDownload.disabled = false;

            updateList();
            map.fitBounds(layers.completed.getBounds(), {padding: [50,50]});
        }

        function smoothAltitude(trace) {
            if (trace.length < 3) return trace;
            const windowSize = 5;
            return trace.map((point, i) => {
                let sum = 0, count = 0;
                for (let j = Math.max(0, i - Math.floor(windowSize/2)); j < Math.min(trace.length, i + Math.floor(windowSize/2) + 1); j++) {
                    sum += trace[j].alt; count++;
                }
                return { ...point, alt: sum / count };
            });
        }

        function updateList() {
            ui.list.innerHTML = '';
            if (state.segments.length > 0) {
                ui.list.classList.add('open');
                state.segments.slice().reverse().forEach((seg, index) => {
                    const idx = state.segments.length - index; 
                    const div = document.createElement('div');
                    div.className = 'measurement-item';
                    const startAlt = seg.trace.length > 0 ? seg.trace[0].alt : 0;
                    const endAlt = seg.trace.length > 0 ? seg.trace[seg.trace.length-1].alt : 0;
                    div.innerHTML = `
                        <div class="m-info">
                            <div class="m-main">#${idx} &bull; ${seg.distance.toFixed(1)}m</div>
                            <div class="m-sub">Alt Gain: ${(endAlt - startAlt).toFixed(1)}m</div>
                        </div>
                        <button class="btn-graph" onclick="showGraph(${seg.id})">Chart</button>
                    `;
                    ui.list.appendChild(div);
                });
            } else {
                ui.list.classList.remove('open');
            }
        }

        function undoLastSegment() {
            if (state.segments.length === 0) return;
            state.segments.pop();
            layers.completed.clearLayers();
            state.segments.forEach(seg => {
                L.polyline([seg.start, seg.end], {color: '#2196F3', weight: 5}).addTo(layers.completed);
                L.marker(seg.start, {icon: createIcon('start')}).addTo(layers.completed);
                L.marker(seg.end, {icon: createIcon('end')}).addTo(layers.completed);
            });
            updateList();
            if (state.segments.length === 0) {
                ui.btnUndo.disabled = true;
                ui.btnDownload.disabled = true;
            }
        }

        window.showGraph = function(segId) {
            const seg = state.segments.find(s => s.id === segId);
            if (!seg || seg.trace.length < 2) { alert("Not enough data for graph"); return; }
            document.getElementById('graphModal').classList.add('active');
            drawChart(seg.trace);
            const startAlt = seg.trace[0].alt;
            const endAlt = seg.trace[seg.trace.length - 1].alt;
            const gain = endAlt - startAlt;
            document.getElementById('modalStartAlt').innerText = `Start: ${startAlt.toFixed(1)}m`;
            document.getElementById('modalEndAlt').innerText = `End: ${endAlt.toFixed(1)}m`;
            document.getElementById('modalGain').innerText = `Change: ${gain > 0 ? '+' : ''}${gain.toFixed(1)}m`;
            document.getElementById('modalGain').style.color = gain >= 0 ? '#4CAF50' : '#f44336';
        };

        window.closeModal = function() {
            document.getElementById('graphModal').classList.remove('active');
        };

        function drawChart(data) {
            const canvas = document.getElementById('profileChart');
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            const width = rect.width; const height = rect.height; const padding = 30;

            ctx.clearRect(0, 0, width, height);

            if (data.length < 2) return;

            const maxDist = data[data.length - 1].dist;
            let minAlt = Infinity, maxAlt = -Infinity;
            data.forEach(p => { if(p.alt < minAlt) minAlt = p.alt; if(p.alt > maxAlt) maxAlt = p.alt; });
            const altRange = maxAlt - minAlt || 1;
            minAlt -= altRange * 0.1; maxAlt += altRange * 0.1;

            const getX = (dist) => padding + (dist / maxDist) * (width - padding * 2);
            const getY = (alt) => height - padding - ((alt - minAlt) / (maxAlt - minAlt)) * (height - padding * 2);

            ctx.beginPath();
            ctx.moveTo(getX(0), height - padding);
            data.forEach(p => ctx.lineTo(getX(p.dist), getY(p.alt)));
            ctx.lineTo(getX(maxDist), height - padding);
            ctx.fillStyle = 'rgba(33, 150, 243, 0.2)';
            ctx.fill();

            ctx.beginPath();
            data.forEach((p, i) => { i === 0 ? ctx.moveTo(getX(p.dist), getY(p.alt)) : ctx.lineTo(getX(p.dist), getY(p.alt)); });
            ctx.strokeStyle = '#2196F3'; ctx.lineWidth = 2; ctx.stroke();

            ctx.fillStyle = '#666'; ctx.font = '10px sans-serif'; ctx.textAlign = 'center';
            ctx.fillText(Math.round(maxAlt) + 'm', 15, getY(maxAlt) + 3);
            ctx.fillText(Math.round(minAlt) + 'm', 15, getY(minAlt) + 3);
            ctx.fillText('0m', getX(0), height - 10);
            ctx.fillText(Math.round(maxDist) + 'm', getX(maxDist), height - 10);
            
            ctx.strokeStyle = '#eee'; ctx.lineWidth = 1; ctx.beginPath();
            ctx.moveTo(padding, padding); ctx.lineTo(padding, height - padding); ctx.lineTo(width - padding, height - padding);
            ctx.stroke();
        }

        function downloadGeoJSON() {
            const features = state.segments.map((seg, index) => ({
                type: "Feature",
                properties: { id: index + 1, distance: seg.distance, start_alt: seg.trace[0].alt, end_alt: seg.trace[seg.trace.length-1].alt },
                geometry: { type: "LineString", coordinates: seg.trace.map(p => [p.lng, p.lat, p.alt]) }
            }));
            const geojson = { type: "FeatureCollection", features: features };
            const blob = new Blob([JSON.stringify(geojson, null, 2)], {type: "application/json"});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = `survey_${new Date().toISOString().slice(0,10)}.geojson`;
            document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        init();
    </script>
</body>
</html>
